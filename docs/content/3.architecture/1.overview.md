---
title: Overview
description: How Universal Data Layer works under the hood
navigation:
  icon: i-lucide-layers
---

## System Design

The Universal Data Layer acts as an intermediate layer between your application and data sources:

```
Application → Universal Data Layer → Data Sources
     ↑              ↓                      ↓
     └── Unified GraphQL API ← Plugins ←──┘
```

## Build Process

### 1. Source Phase

Plugins fetch data from external APIs and create nodes in the internal data store.

### 2. Transform Phase

Data is processed, relationships are established, and the GraphQL schema is generated.

### 3. Query Phase

Your application queries the unified GraphQL API instead of making direct API calls.

## Performance Optimizations

### Request Deduplication

Identical requests are automatically batched and cached, reducing API calls by up to 90%.

### Intelligent Caching

Multiple cache layers work together:

- **Memory Cache**: In-process caching for hot data
- **Disk Cache**: Persistent cache between builds
- **CDN Cache**: Edge caching for production

### Incremental Builds

Only changed data is refetched, dramatically reducing build times.

## Deployment Models

### Static Generation

Pre-build all data at build time for maximum performance.

### Incremental Static Regeneration

Update specific pages when data changes without full rebuilds.

### Edge Runtime

Deploy the data layer to edge functions for global low-latency access.

## Coming Soon

- **Distributed Architecture**: Multi-region data layer deployment
- **Real-time Sync**: WebSocket-based live data updates
- **Query Optimization**: Automatic query analysis and optimization
- **Data Federation**: Compose multiple data layers into one
