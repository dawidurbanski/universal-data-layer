import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, readFileSync, mkdirSync, rmSync, writeFileSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import {
  FileWriter,
  writeGeneratedFiles,
} from '@/codegen/output/file-writer.js';
import type { ContentTypeDefinition } from '@/codegen/types/schema.js';

describe('FileWriter', () => {
  let tempDir: string;

  beforeEach(() => {
    // Create a unique temp directory for each test
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    // Clean up temp directory
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  describe('constructor', () => {
    it('should use default options', () => {
      const writer = new FileWriter();
      // Writer should be created without errors
      expect(writer).toBeDefined();
    });

    it('should auto-detect single-file mode from .ts extension', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeTypes(schemas, 'export interface Product { name: string; }');

      // Should write to single file
      expect(existsSync(output)).toBe(true);
      expect(existsSync(join(tempDir, 'types'))).toBe(false);
    });

    it('should use multi-file mode for directory paths', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeTypes(schemas, 'export interface Product { name: string; }');

      // Should create directory structure
      expect(existsSync(join(output, 'types'))).toBe(true);
    });
  });

  describe('writeTypes', () => {
    it('should write types to single file', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      const result = writer.writeTypes(schemas, code);

      expect(result.written).toContain(output);
      expect(existsSync(output)).toBe(true);
      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('export interface Product');
    });

    it('should write types to multi-file structure', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      const result = writer.writeTypes(schemas, code);

      expect(result.written.length).toBeGreaterThan(0);
      expect(existsSync(join(output, 'types'))).toBe(true);
    });

    it('should add header to generated files', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('Auto-generated by universal-data-layer');
      expect(content).toContain('DO NOT EDIT MANUALLY');
    });

    it('should include timestamp when enabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        includeTimestamp: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('Generated at:');
    });

    it('should not include timestamp by default', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).not.toContain('Generated at:');
    });

    it('should include custom header when provided', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        customHeader: 'Custom notice\nLine 2',
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('Custom notice');
      expect(content).toContain('Line 2');
    });
  });

  describe('writeGuards', () => {
    it('should write guards to file', () => {
      const output = join(tempDir, 'guards.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code =
        'export function isProduct(value: unknown): value is Product { return true; }';

      const result = writer.writeGuards(schemas, code);

      expect(result.written).toContain(output);
      expect(existsSync(output)).toBe(true);
    });
  });

  describe('writeAll', () => {
    it('should write all file types', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      const result = writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
        guards: {
          schemas,
          code: 'export function isProduct(value: unknown): value is Product { return true; }',
        },
      });

      expect(result.written.length).toBeGreaterThan(0);
      expect(existsSync(join(output, 'types'))).toBe(true);
      expect(existsSync(join(output, 'guards'))).toBe(true);
    });

    it('should generate root barrel file in multi-file mode', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({
        output,
        mode: 'multi',
        generateBarrel: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
      });

      const barrelPath = join(output, 'index.ts');
      expect(existsSync(barrelPath)).toBe(true);
      const content = readFileSync(barrelPath, 'utf-8');
      expect(content).toContain("export * from './types/index'");
    });

    it('should skip barrel file when disabled', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({
        output,
        mode: 'multi',
        generateBarrel: false,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
      });

      const barrelPath = join(output, 'index.ts');
      expect(existsSync(barrelPath)).toBe(false);
    });

    it('should only write provided categories', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
        // No guards
      });

      expect(existsSync(join(output, 'types'))).toBe(true);
      expect(existsSync(join(output, 'guards'))).toBe(false);
    });
  });

  describe('clean', () => {
    it('should clean single output file', () => {
      const output = join(tempDir, 'types.ts');
      writeFileSync(output, 'test content');
      const writer = new FileWriter({ output, mode: 'single' });

      const result = writer.clean();

      expect(result.deleted).toContain(output);
      expect(existsSync(output)).toBe(false);
    });

    it('should clean multi-file directories', () => {
      const output = join(tempDir, 'generated');
      mkdirSync(join(output, 'types'), { recursive: true });
      mkdirSync(join(output, 'guards'), { recursive: true });
      writeFileSync(join(output, 'types', 'product.ts'), 'test');
      writeFileSync(join(output, 'guards', 'product.ts'), 'test');

      const writer = new FileWriter({ output, mode: 'multi' });

      const result = writer.clean();

      expect(result.deleted.length).toBeGreaterThan(0);
      expect(existsSync(join(output, 'types'))).toBe(false);
      expect(existsSync(join(output, 'guards'))).toBe(false);
    });

    it('should clean specific categories', () => {
      const output = join(tempDir, 'generated');
      mkdirSync(join(output, 'types'), { recursive: true });
      mkdirSync(join(output, 'guards'), { recursive: true });
      writeFileSync(join(output, 'types', 'product.ts'), 'test');
      writeFileSync(join(output, 'guards', 'product.ts'), 'test');

      const writer = new FileWriter({ output, mode: 'multi' });

      writer.clean(['types']);

      expect(existsSync(join(output, 'types'))).toBe(false);
      expect(existsSync(join(output, 'guards'))).toBe(true);
    });
  });

  describe('preview', () => {
    it('should return files that would be written', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      const files = writer.preview('types', schemas, code);

      expect(files.length).toBeGreaterThan(0);
      expect(files[0]?.path).toBeDefined();
      expect(files[0]?.content).toBeDefined();
    });

    it('should not actually write files', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.preview('types', schemas, code);

      expect(existsSync(output)).toBe(false);
    });
  });

  describe('incremental write', () => {
    it('should skip unchanged files when incrementalWrite is enabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        incrementalWrite: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      // First write
      const result1 = writer.writeTypes(schemas, code);
      expect(result1.written).toContain(output);

      // Second write with same content
      const result2 = writer.writeTypes(schemas, code);
      expect(result2.skipped).toContain(output);
      expect(result2.written).not.toContain(output);
    });

    it('should write changed files when incrementalWrite is enabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        incrementalWrite: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      // First write
      const result1 = writer.writeTypes(
        schemas,
        'export interface Product { name: string; }'
      );
      expect(result1.written).toContain(output);

      // Second write with different content
      const result2 = writer.writeTypes(
        schemas,
        'export interface Product { name: string; price: number; }'
      );
      expect(result2.written).toContain(output);
    });

    it('should always write when incrementalWrite is disabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        incrementalWrite: false,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      // First write
      const result1 = writer.writeTypes(schemas, code);
      expect(result1.written).toContain(output);

      // Second write with same content - should still write
      const result2 = writer.writeTypes(schemas, code);
      expect(result2.written).toContain(output);
      expect(result2.skipped).not.toContain(output);
    });
  });

  describe('kebab-case conversion', () => {
    it('should convert PascalCase to kebab-case for file names', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'ProductCategory',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface ProductCategory { name: string; }';

      const files = writer.preview('types', schemas, code);

      expect(files.some((f) => f.path.includes('product-category'))).toBe(true);
    });
  });
});

describe('writeGeneratedFiles', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should be a convenience function', () => {
    const output = join(tempDir, 'generated');
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];

    const result = writeGeneratedFiles(
      {
        types: { schemas, code: 'export interface Product { name: string; }' },
      },
      { output }
    );

    expect(result.written.length).toBeGreaterThan(0);
  });
});

describe('extractTypeCode edge cases', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should extract code with JSDoc comments followed by matching export', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // Code with JSDoc comment preceding the interface
    const code = `/**
 * Product interface
 */
export interface Product {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export interface Product');
  });

  it('should extract code with JSDoc containing only comment markers', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // JSDoc with just the closing marker on next line
    const code = `/**
 */
export interface Product {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export interface Product');
  });

  it('should extract code with multi-line JSDoc and asterisks', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = `/**
 * The Product interface
 * @description A product entity
 */
export interface Product {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export interface Product');
    expect(files[0]?.content).toContain('The Product interface');
  });

  it('should extract guards with JSDoc comments', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // Code with JSDoc for type guard
    const code = `/**
 * Type guard for Product
 */
export function isProduct(value: unknown): value is Product {
  return typeof value === 'object';
}`;

    const files = writer.preview('guards', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export function isProduct');
  });

  it('should extract assertion guards', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = `export function assertProduct(value: unknown): asserts value is Product {
  if (!isProduct(value)) {
    throw new Error('Not a Product');
  }
}`;

    const files = writer.preview('guards', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export function assertProduct');
  });

  it('should handle code with nested braces', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = `export interface Product {
  name: string;
  nested: {
    deep: {
      value: number;
    };
  };
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('nested');
    expect(files[0]?.content).toContain('deep');
  });

  it('should fall back to index file when code cannot be split', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // Code that doesn't match the extraction patterns
    const code = `const someHelper = 'test';`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.path).toBe('types/index.ts');
  });
});

describe('writeAll with guards barrel', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should generate root barrel with guards export', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({
      output,
      mode: 'multi',
      generateBarrel: true,
    });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];

    writer.writeAll({
      guards: {
        schemas,
        code: 'export function isProduct(value: unknown): value is Product { return true; }',
      },
    });

    const barrelPath = join(output, 'index.ts');
    expect(existsSync(barrelPath)).toBe(true);
    const content = readFileSync(barrelPath, 'utf-8');
    expect(content).toContain("export * from './guards/index'");
  });

  it('should generate root barrel with both types and guards exports', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({
      output,
      mode: 'multi',
      generateBarrel: true,
    });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];

    writer.writeAll({
      types: { schemas, code: 'export interface Product { name: string; }' },
      guards: {
        schemas,
        code: 'export function isProduct(value: unknown): value is Product { return true; }',
      },
    });

    const barrelPath = join(output, 'index.ts');
    const content = readFileSync(barrelPath, 'utf-8');
    expect(content).toContain("export * from './types/index'");
    expect(content).toContain("export * from './guards/index'");
  });

  it('should skip unchanged root barrel on second write', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({
      output,
      mode: 'multi',
      generateBarrel: true,
      incrementalWrite: true,
    });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];

    // First write
    const result1 = writer.writeAll({
      types: { schemas, code: 'export interface Product { name: string; }' },
    });
    const barrelPath = join(output, 'index.ts');
    expect(result1.written).toContain(barrelPath);

    // Second write with same content
    const result2 = writer.writeAll({
      types: { schemas, code: 'export interface Product { name: string; }' },
    });
    expect(result2.skipped).toContain(barrelPath);
  });

  it('should not generate root barrel when schemas are empty', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({
      output,
      mode: 'multi',
      generateBarrel: true,
    });
    const emptySchemas: ContentTypeDefinition[] = [];

    writer.writeAll({
      types: { schemas: emptySchemas, code: '' },
    });

    const barrelPath = join(output, 'index.ts');
    expect(existsSync(barrelPath)).toBe(false);
  });
});

describe('addHeader edge cases', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should not add header when content already has JSDoc header', () => {
    const output = join(tempDir, 'types.ts');
    const writer = new FileWriter({ output, mode: 'single' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // Content that already starts with JSDoc
    const code = `/**
 * Existing header
 */
export interface Product { name: string; }`;

    writer.writeTypes(schemas, code);

    const content = readFileSync(output, 'utf-8');
    // Should not have double headers
    const headerCount = (content.match(/Auto-generated by/g) || []).length;
    expect(headerCount).toBe(0);
    expect(content).toContain('Existing header');
  });

  it('should not add header when content starts with whitespace then JSDoc', () => {
    const output = join(tempDir, 'types.ts');
    const writer = new FileWriter({ output, mode: 'single' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // Content with leading whitespace and JSDoc
    const code = `  /**
 * Existing header with whitespace
 */
export interface Product { name: string; }`;

    writer.writeTypes(schemas, code);

    const content = readFileSync(output, 'utf-8');
    // The trim() in addHeader should detect the existing header
    expect(content).toContain('Existing header with whitespace');
  });

  it('should preview in single mode with header', () => {
    const output = join(tempDir, 'types.ts');
    const writer = new FileWriter({ output, mode: 'single' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = 'export interface Product { name: string; }';

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.path).toBe(output);
    expect(files[0]?.content).toContain(
      'Auto-generated by universal-data-layer'
    );
    expect(files[0]?.content).toContain('export interface Product');
  });
});

describe('clean edge cases', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should handle clean when files do not exist in single mode', () => {
    const output = join(tempDir, 'nonexistent.ts');
    const writer = new FileWriter({ output, mode: 'single' });

    const result = writer.clean();

    expect(result.deleted).toHaveLength(0);
  });

  it('should handle clean when directories do not exist in multi mode', () => {
    const output = join(tempDir, 'nonexistent');
    const writer = new FileWriter({ output, mode: 'multi' });

    const result = writer.clean();

    expect(result.deleted).toHaveLength(0);
  });

  it('should clean root barrel file', () => {
    const output = join(tempDir, 'generated');
    mkdirSync(output, { recursive: true });
    const barrelPath = join(output, 'index.ts');
    writeFileSync(barrelPath, 'export * from "./types"');

    const writer = new FileWriter({ output, mode: 'multi' });
    const result = writer.clean();

    expect(result.deleted).toContain(barrelPath);
    expect(existsSync(barrelPath)).toBe(false);
  });
});

describe('extractTypeCode branch coverage', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should handle JSDoc with standalone closing marker on its own line', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // JSDoc where the closing marker */ is on a line by itself (not preceded by *)
    const code = `/**
 * Description
*/
export interface Product {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export interface Product');
  });

  it('should handle JSDoc with empty line in comment block', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // JSDoc with empty lines between comment lines
    const code = `/**
 * Description

 * More description
 */
export interface Product {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export interface Product');
  });

  it('should handle code with type alias instead of interface', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = `export type Product = {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export type Product');
  });

  it('should handle empty code', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = '';

    const files = writer.preview('types', schemas, code);

    // Empty code with no matching types should return empty array
    expect(files.length).toBe(0);
  });

  it('should handle code with multiple empty lines', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    const code = `


export interface Product {
  name: string;
}


`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    expect(files[0]?.content).toContain('export interface Product');
  });

  it('should handle JSDoc that does not precede matching export', () => {
    const output = join(tempDir, 'generated');
    const writer = new FileWriter({ output, mode: 'multi' });
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];
    // JSDoc followed by unrelated code, then the actual interface
    const code = `/**
 * Some helper documentation
 */
const helper = 'test';

export interface Product {
  name: string;
}`;

    const files = writer.preview('types', schemas, code);

    expect(files.length).toBe(1);
    // Should extract just the interface without the unrelated JSDoc
    expect(files[0]?.content).toContain('export interface Product');
  });
});
