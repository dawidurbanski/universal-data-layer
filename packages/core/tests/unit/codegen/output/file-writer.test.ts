import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, readFileSync, mkdirSync, rmSync, writeFileSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import {
  FileWriter,
  writeGeneratedFiles,
} from '@/codegen/output/file-writer.js';
import type { ContentTypeDefinition } from '@/codegen/types/schema.js';

describe('FileWriter', () => {
  let tempDir: string;

  beforeEach(() => {
    // Create a unique temp directory for each test
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    // Clean up temp directory
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  describe('constructor', () => {
    it('should use default options', () => {
      const writer = new FileWriter();
      // Writer should be created without errors
      expect(writer).toBeDefined();
    });

    it('should auto-detect single-file mode from .ts extension', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeTypes(schemas, 'export interface Product { name: string; }');

      // Should write to single file
      expect(existsSync(output)).toBe(true);
      expect(existsSync(join(tempDir, 'types'))).toBe(false);
    });

    it('should use multi-file mode for directory paths', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeTypes(schemas, 'export interface Product { name: string; }');

      // Should create directory structure
      expect(existsSync(join(output, 'types'))).toBe(true);
    });
  });

  describe('writeTypes', () => {
    it('should write types to single file', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      const result = writer.writeTypes(schemas, code);

      expect(result.written).toContain(output);
      expect(existsSync(output)).toBe(true);
      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('export interface Product');
    });

    it('should write types to multi-file structure', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      const result = writer.writeTypes(schemas, code);

      expect(result.written.length).toBeGreaterThan(0);
      expect(existsSync(join(output, 'types'))).toBe(true);
    });

    it('should add header to generated files', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('Auto-generated by universal-data-layer');
      expect(content).toContain('DO NOT EDIT MANUALLY');
    });

    it('should include timestamp when enabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        includeTimestamp: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('Generated at:');
    });

    it('should not include timestamp by default', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).not.toContain('Generated at:');
    });

    it('should include custom header when provided', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        customHeader: 'Custom notice\nLine 2',
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.writeTypes(schemas, code);

      const content = readFileSync(output, 'utf-8');
      expect(content).toContain('Custom notice');
      expect(content).toContain('Line 2');
    });
  });

  describe('writeGuards', () => {
    it('should write guards to file', () => {
      const output = join(tempDir, 'guards.ts');
      const writer = new FileWriter({ output, mode: 'single' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code =
        'export function isProduct(value: unknown): value is Product { return true; }';

      const result = writer.writeGuards(schemas, code);

      expect(result.written).toContain(output);
      expect(existsSync(output)).toBe(true);
    });
  });

  describe('writeAll', () => {
    it('should write all file types', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      const result = writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
        guards: {
          schemas,
          code: 'export function isProduct(value: unknown): value is Product { return true; }',
        },
      });

      expect(result.written.length).toBeGreaterThan(0);
      expect(existsSync(join(output, 'types'))).toBe(true);
      expect(existsSync(join(output, 'guards'))).toBe(true);
    });

    it('should generate root barrel file in multi-file mode', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({
        output,
        mode: 'multi',
        generateBarrel: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
      });

      const barrelPath = join(output, 'index.ts');
      expect(existsSync(barrelPath)).toBe(true);
      const content = readFileSync(barrelPath, 'utf-8');
      expect(content).toContain("export * from './types/index'");
    });

    it('should skip barrel file when disabled', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({
        output,
        mode: 'multi',
        generateBarrel: false,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
      });

      const barrelPath = join(output, 'index.ts');
      expect(existsSync(barrelPath)).toBe(false);
    });

    it('should only write provided categories', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      writer.writeAll({
        types: { schemas, code: 'export interface Product { name: string; }' },
        // No guards
      });

      expect(existsSync(join(output, 'types'))).toBe(true);
      expect(existsSync(join(output, 'guards'))).toBe(false);
    });
  });

  describe('clean', () => {
    it('should clean single output file', () => {
      const output = join(tempDir, 'types.ts');
      writeFileSync(output, 'test content');
      const writer = new FileWriter({ output, mode: 'single' });

      const result = writer.clean();

      expect(result.deleted).toContain(output);
      expect(existsSync(output)).toBe(false);
    });

    it('should clean multi-file directories', () => {
      const output = join(tempDir, 'generated');
      mkdirSync(join(output, 'types'), { recursive: true });
      mkdirSync(join(output, 'guards'), { recursive: true });
      writeFileSync(join(output, 'types', 'product.ts'), 'test');
      writeFileSync(join(output, 'guards', 'product.ts'), 'test');

      const writer = new FileWriter({ output, mode: 'multi' });

      const result = writer.clean();

      expect(result.deleted.length).toBeGreaterThan(0);
      expect(existsSync(join(output, 'types'))).toBe(false);
      expect(existsSync(join(output, 'guards'))).toBe(false);
    });

    it('should clean specific categories', () => {
      const output = join(tempDir, 'generated');
      mkdirSync(join(output, 'types'), { recursive: true });
      mkdirSync(join(output, 'guards'), { recursive: true });
      writeFileSync(join(output, 'types', 'product.ts'), 'test');
      writeFileSync(join(output, 'guards', 'product.ts'), 'test');

      const writer = new FileWriter({ output, mode: 'multi' });

      writer.clean(['types']);

      expect(existsSync(join(output, 'types'))).toBe(false);
      expect(existsSync(join(output, 'guards'))).toBe(true);
    });
  });

  describe('preview', () => {
    it('should return files that would be written', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      const files = writer.preview('types', schemas, code);

      expect(files.length).toBeGreaterThan(0);
      expect(files[0]?.path).toBeDefined();
      expect(files[0]?.content).toBeDefined();
    });

    it('should not actually write files', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      writer.preview('types', schemas, code);

      expect(existsSync(output)).toBe(false);
    });
  });

  describe('incremental write', () => {
    it('should skip unchanged files when incrementalWrite is enabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        incrementalWrite: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      // First write
      const result1 = writer.writeTypes(schemas, code);
      expect(result1.written).toContain(output);

      // Second write with same content
      const result2 = writer.writeTypes(schemas, code);
      expect(result2.skipped).toContain(output);
      expect(result2.written).not.toContain(output);
    });

    it('should write changed files when incrementalWrite is enabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        incrementalWrite: true,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];

      // First write
      const result1 = writer.writeTypes(
        schemas,
        'export interface Product { name: string; }'
      );
      expect(result1.written).toContain(output);

      // Second write with different content
      const result2 = writer.writeTypes(
        schemas,
        'export interface Product { name: string; price: number; }'
      );
      expect(result2.written).toContain(output);
    });

    it('should always write when incrementalWrite is disabled', () => {
      const output = join(tempDir, 'types.ts');
      const writer = new FileWriter({
        output,
        mode: 'single',
        incrementalWrite: false,
      });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'Product',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface Product { name: string; }';

      // First write
      const result1 = writer.writeTypes(schemas, code);
      expect(result1.written).toContain(output);

      // Second write with same content - should still write
      const result2 = writer.writeTypes(schemas, code);
      expect(result2.written).toContain(output);
      expect(result2.skipped).not.toContain(output);
    });
  });

  describe('kebab-case conversion', () => {
    it('should convert PascalCase to kebab-case for file names', () => {
      const output = join(tempDir, 'generated');
      const writer = new FileWriter({ output, mode: 'multi' });
      const schemas: ContentTypeDefinition[] = [
        {
          name: 'ProductCategory',
          fields: [{ name: 'name', type: 'string', required: true }],
        },
      ];
      const code = 'export interface ProductCategory { name: string; }';

      const files = writer.preview('types', schemas, code);

      expect(files.some((f) => f.path.includes('product-category'))).toBe(true);
    });
  });
});

describe('writeGeneratedFiles', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = join(
      tmpdir(),
      `udl-codegen-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(tempDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should be a convenience function', () => {
    const output = join(tempDir, 'generated');
    const schemas: ContentTypeDefinition[] = [
      {
        name: 'Product',
        fields: [{ name: 'name', type: 'string', required: true }],
      },
    ];

    const result = writeGeneratedFiles(
      {
        types: { schemas, code: 'export interface Product { name: string; }' },
      },
      { output }
    );

    expect(result.written.length).toBeGreaterThan(0);
  });
});
